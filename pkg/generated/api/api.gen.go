// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	externalRef0 "github.com/corbado/corbado-go/pkg/generated/common"
	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for AuthEventMethod.
const (
	AuthEventMethodEmailLink       AuthEventMethod = "email_link"
	AuthEventMethodEmailOtp        AuthEventMethod = "email_otp"
	AuthEventMethodPasskey         AuthEventMethod = "passkey"
	AuthEventMethodPassword        AuthEventMethod = "password"
	AuthEventMethodPhoneOtp        AuthEventMethod = "phone_otp"
	AuthEventMethodSocialGithub    AuthEventMethod = "social_github"
	AuthEventMethodSocialGoogle    AuthEventMethod = "social_google"
	AuthEventMethodSocialMicrosoft AuthEventMethod = "social_microsoft"
)

// Defines values for AuthEventStatus.
const (
	Failure AuthEventStatus = "failure"
	Success AuthEventStatus = "success"
)

// Defines values for AuthEventType.
const (
	Login           AuthEventType = "login"
	NewPasskeyAdded AuthEventType = "new_passkey_added"
	SignUp          AuthEventType = "sign_up"
)

// Defines values for ChallengeStatus.
const (
	ChallengeStatusCompleted ChallengeStatus = "completed"
	ChallengeStatusExpired   ChallengeStatus = "expired"
	ChallengeStatusPending   ChallengeStatus = "pending"
)

// Defines values for ChallengeType.
const (
	ChallengeTypeEmailLink ChallengeType = "email_link"
	ChallengeTypeEmailOtp  ChallengeType = "email_otp"
	ChallengeTypeSmsOtp    ChallengeType = "sms_otp"
)

// Defines values for ConnectTokenStatus.
const (
	ConnectTokenStatusConsumed ConnectTokenStatus = "consumed"
	ConnectTokenStatusInitial  ConnectTokenStatus = "initial"
)

// Defines values for ConnectTokenType.
const (
	PasskeyAppend ConnectTokenType = "passkey-append"
	PasskeyDelete ConnectTokenType = "passkey-delete"
	PasskeyList   ConnectTokenType = "passkey-list"
)

// Defines values for CredentialStatus.
const (
	CredentialStatusActive  CredentialStatus = "active"
	CredentialStatusPending CredentialStatus = "pending"
)

// Defines values for CredentialTransport.
const (
	Ble       CredentialTransport = "ble"
	Hybrid    CredentialTransport = "hybrid"
	Internal  CredentialTransport = "internal"
	Nfc       CredentialTransport = "nfc"
	SmartCard CredentialTransport = "smart-card"
	Usb       CredentialTransport = "usb"
)

// Defines values for CrossDeviceAuthenticationStrategy.
const (
	Maximize CrossDeviceAuthenticationStrategy = "maximize"
	Minimize CrossDeviceAuthenticationStrategy = "minimize"
	Standard CrossDeviceAuthenticationStrategy = "standard"
)

// Defines values for DecisionTag.
const (
	DecisionTagDefaultDeny                          DecisionTag = "default-deny"
	DecisionTagDeviceLocalPlatformPasskeyExperiment DecisionTag = "device-local-platform-passkey-experiment"
	DecisionTagEnvBlacklisted                       DecisionTag = "env-blacklisted"
	DecisionTagEnvNoPkSupport                       DecisionTag = "env-no-pk-support"
	DecisionTagPasskeyListInitiatedProcess          DecisionTag = "passkey-list-initiated-process"
	DecisionTagProcessPkLoginCrossPlatformCompleted DecisionTag = "process-pk-login-cross-platform-completed"
	DecisionTagProcessPkLoginIncomplete             DecisionTag = "process-pk-login-incomplete"
	DecisionTagProcessPkLoginNotOffered             DecisionTag = "process-pk-login-not-offered"
	DecisionTagProcessPkLoginPlatformCompleted      DecisionTag = "process-pk-login-platform-completed"
	DecisionTagProcessPkLoginSkCompleted            DecisionTag = "process-pk-login-sk-completed"
	DecisionTagUserAppendBlacklisted                DecisionTag = "user-append-blacklisted"
	DecisionTagUserCrossPlatformPkHighConfidence    DecisionTag = "user-cross-platform-pk-high-confidence"
	DecisionTagUserEnvNoPks                         DecisionTag = "user-env-no-pks"
	DecisionTagUserLoginBlacklisted                 DecisionTag = "user-login-blacklisted"
	DecisionTagUserNegativeEnvHistory               DecisionTag = "user-negative-env-history"
	DecisionTagUserNoPks                            DecisionTag = "user-no-pks"
	DecisionTagUserPlatformPkHighConfidence         DecisionTag = "user-platform-pk-high-confidence"
	DecisionTagUserPositiveEnvHistory               DecisionTag = "user-positive-env-history"
	DecisionTagUserSecurityKey                      DecisionTag = "user-security-key"
)

// Defines values for DetectionTagCategory.
const (
	ClientEnv DetectionTagCategory = "clientEnv"
	History   DetectionTagCategory = "history"
	Passkey   DetectionTagCategory = "passkey"
	Support   DetectionTagCategory = "support"
)

// Defines values for IdentifierStatus.
const (
	IdentifierStatusPending  IdentifierStatus = "pending"
	IdentifierStatusPrimary  IdentifierStatus = "primary"
	IdentifierStatusVerified IdentifierStatus = "verified"
)

// Defines values for IdentifierType.
const (
	Email    IdentifierType = "email"
	Phone    IdentifierType = "phone"
	Username IdentifierType = "username"
)

// Defines values for LongSessionStatus.
const (
	Active            LongSessionStatus = "active"
	Expired           LongSessionStatus = "expired"
	InactivityReached LongSessionStatus = "inactivity_reached"
	LoggedOut         LongSessionStatus = "logged_out"
	Revoked           LongSessionStatus = "revoked"
)

// Defines values for PasskeyChallengeStatus.
const (
	PasskeyChallengeStatusCompleted PasskeyChallengeStatus = "completed"
	PasskeyChallengeStatusConsumed  PasskeyChallengeStatus = "consumed"
	PasskeyChallengeStatusPending   PasskeyChallengeStatus = "pending"
)

// Defines values for PasskeyChallengeType.
const (
	Authenticate PasskeyChallengeType = "authenticate"
	Register     PasskeyChallengeType = "register"
)

// Defines values for PasskeyDataCeremonyType.
const (
	Cda         PasskeyDataCeremonyType = "cda"
	Local       PasskeyDataCeremonyType = "local"
	SecurityKey PasskeyDataCeremonyType = "security-key"
)

// Defines values for PasskeyEventType.
const (
	PasskeyEventTypeAppendCredentialExists                  PasskeyEventType = "append-credential-exists"
	PasskeyEventTypeAppendError                             PasskeyEventType = "append-error"
	PasskeyEventTypeAppendExplicitAbort                     PasskeyEventType = "append-explicit-abort"
	PasskeyEventTypeLoginError                              PasskeyEventType = "login-error"
	PasskeyEventTypeLoginExplicitAbort                      PasskeyEventType = "login-explicit-abort"
	PasskeyEventTypeLoginOneTapSwitch                       PasskeyEventType = "login-one-tap-switch"
	PasskeyEventTypeUserAppendAfterCrossPlatformBlacklisted PasskeyEventType = "user-append-after-cross-platform-blacklisted"
	PasskeyEventTypeUserAppendAfterLoginErrorBlacklisted    PasskeyEventType = "user-append-after-login-error-blacklisted"
	PasskeyEventTypeUserLoginBlacklisted                    PasskeyEventType = "user-login-blacklisted"
)

// Defines values for UserStatus.
const (
	UserStatusActive   UserStatus = "active"
	UserStatusDisabled UserStatus = "disabled"
	UserStatusPending  UserStatus = "pending"
)

// AuthEvent defines model for authEvent.
type AuthEvent struct {
	AuthEventID string `json:"authEventID"`

	// Created Timestamp of when the entity was created in yyyy-MM-dd'T'HH:mm:ss format
	Created   externalRef0.Created `json:"created"`
	EventType AuthEventType        `json:"eventType"`
	Method    AuthEventMethod      `json:"method"`
	Status    AuthEventStatus      `json:"status"`

	// UserID ID of the user
	UserID   externalRef0.UserID `json:"userID"`
	Username string              `json:"username"`
}

// AuthEventCreateReq defines model for authEventCreateReq.
type AuthEventCreateReq struct {
	ClientInformation ClientInformation `json:"clientInformation"`
	EventType         AuthEventType     `json:"eventType"`
	Method            AuthEventMethod   `json:"method"`
	Status            AuthEventStatus   `json:"status"`
	Username          string            `json:"username"`
}

// AuthEventMethod defines model for authEventMethod.
type AuthEventMethod string

// AuthEventStatus defines model for authEventStatus.
type AuthEventStatus string

// AuthEventType defines model for authEventType.
type AuthEventType string

// Challenge defines model for challenge.
type Challenge struct {
	ChallengeID     string          `json:"challengeID"`
	IdentifierValue string          `json:"identifierValue"`
	Status          ChallengeStatus `json:"status"`
	Type            ChallengeType   `json:"type"`
	Value           string          `json:"value"`
}

// ChallengeCreateReq defines model for challengeCreateReq.
type ChallengeCreateReq struct {
	ChallengeMetadata *map[string]interface{} `json:"challengeMetadata,omitempty"`
	ChallengeType     ChallengeType           `json:"challengeType"`
	ClientInformation ClientInformation       `json:"clientInformation"`
	IdentifierValue   string                  `json:"identifierValue"`
}

// ChallengeStatus defines model for challengeStatus.
type ChallengeStatus string

// ChallengeType defines model for challengeType.
type ChallengeType string

// ChallengeUpdateReq defines model for challengeUpdateReq.
type ChallengeUpdateReq struct {
	Value string `json:"value"`
}

// ClientInformation defines model for clientInformation.
type ClientInformation struct {
	// BluetoothAvailable Client's Bluetooth availability
	BluetoothAvailable *bool `json:"bluetoothAvailable,omitempty"`

	// ClientEnvHandle Client's environment handle
	ClientEnvHandle               *string                `json:"clientEnvHandle,omitempty"`
	ConditionalMediationAvailable bool                   `json:"conditionalMediationAvailable"`
	JavaScriptHighEntropy         *JavaScriptHighEntropy `json:"javaScriptHighEntropy,omitempty"`

	// JavascriptFingerprint Client's fingerprint
	JavascriptFingerprint *string `json:"javascriptFingerprint,omitempty"`

	// PasswordManagerAvailable Client's password manager availability
	PasswordManagerAvailable *bool `json:"passwordManagerAvailable,omitempty"`

	// RemoteAddress Client's IP address
	RemoteAddress string `json:"remoteAddress"`

	// UserAgent Client's user agent
	UserAgent                                   string `json:"userAgent"`
	UserVerifyingPlatformAuthenticatorAvailable bool   `json:"userVerifyingPlatformAuthenticatorAvailable"`
}

// ConnectToken defines model for connectToken.
type ConnectToken struct {
	ConnectTokenStatus ConnectTokenStatus `json:"connectTokenStatus"`
	Data               ConnectTokenData   `json:"data"`
	Expires            int                `json:"expires"`
	Id                 string             `json:"id"`
	Secret             *string            `json:"secret,omitempty"`
	TokenType          ConnectTokenType   `json:"tokenType"`
}

// ConnectTokenCreateReq defines model for connectTokenCreateReq.
type ConnectTokenCreateReq struct {
	Data                 ConnectTokenData `json:"data"`
	MaxLifetimeInSeconds *int             `json:"maxLifetimeInSeconds,omitempty"`
	Type                 ConnectTokenType `json:"type"`
}

// ConnectTokenData defines model for connectTokenData.
type ConnectTokenData struct {
	union json.RawMessage
}

// ConnectTokenDataPasskeyAppend defines model for connectTokenDataPasskeyAppend.
type ConnectTokenDataPasskeyAppend struct {
	DisplayName string `json:"displayName"`
	Identifier  string `json:"identifier"`
}

// ConnectTokenDataPasskeyDelete defines model for connectTokenDataPasskeyDelete.
type ConnectTokenDataPasskeyDelete struct {
	Identifier string `json:"identifier"`
}

// ConnectTokenDataPasskeyList defines model for connectTokenDataPasskeyList.
type ConnectTokenDataPasskeyList struct {
	Identifier string `json:"identifier"`
}

// ConnectTokenList defines model for connectTokenList.
type ConnectTokenList struct {
	ConnectTokens []ConnectToken      `json:"connectTokens"`
	Paging        externalRef0.Paging `json:"paging"`
}

// ConnectTokenStatus defines model for connectTokenStatus.
type ConnectTokenStatus string

// ConnectTokenType defines model for connectTokenType.
type ConnectTokenType string

// ConnectTokenUpdateReq defines model for connectTokenUpdateReq.
type ConnectTokenUpdateReq struct {
	Status ConnectTokenStatus `json:"status"`
}

// Credential defines model for credential.
type Credential struct {
	AttestationType     string `json:"attestationType"`
	AuthenticatorAAGUID string `json:"authenticatorAAGUID"`
	BackupEligible      bool   `json:"backupEligible"`
	BackupState         bool   `json:"backupState"`

	// Created Timestamp of when the entity was created in yyyy-MM-dd'T'HH:mm:ss format
	Created      externalRef0.Created `json:"created"`
	CredentialID string               `json:"credentialID"`
	Id           string               `json:"id"`

	// LastUsed Timestamp of when the passkey was last used in yyyy-MM-dd'T'HH:mm:ss format
	LastUsed      string `json:"lastUsed"`
	SourceBrowser string `json:"sourceBrowser"`
	SourceOS      string `json:"sourceOS"`

	// Status Status
	Status    CredentialStatus      `json:"status"`
	Transport []CredentialTransport `json:"transport"`
}

// CredentialStatus Status
type CredentialStatus string

// CredentialTransport defines model for Credential.Transport.
type CredentialTransport string

// CredentialList defines model for credentialList.
type CredentialList struct {
	Credentials []Credential        `json:"credentials"`
	Paging      externalRef0.Paging `json:"paging"`
}

// CrossDeviceAuthenticationStrategy defines model for crossDeviceAuthenticationStrategy.
type CrossDeviceAuthenticationStrategy string

// DecisionTag defines model for decisionTag.
type DecisionTag string

// DetectionTag defines model for detectionTag.
type DetectionTag struct {
	Category DetectionTagCategory `json:"category"`
	Name     string               `json:"name"`
}

// DetectionTagCategory defines model for DetectionTag.Category.
type DetectionTagCategory string

// Identifier defines model for identifier.
type Identifier struct {
	IdentifierID string           `json:"identifierID"`
	Status       IdentifierStatus `json:"status"`
	Type         IdentifierType   `json:"type"`
	UserID       string           `json:"userID"`
	Value        string           `json:"value"`
}

// IdentifierCreateReq defines model for identifierCreateReq.
type IdentifierCreateReq struct {
	IdentifierType  IdentifierType   `json:"identifierType"`
	IdentifierValue string           `json:"identifierValue"`
	Status          IdentifierStatus `json:"status"`
}

// IdentifierList defines model for identifierList.
type IdentifierList struct {
	Identifiers []Identifier        `json:"identifiers"`
	Paging      externalRef0.Paging `json:"paging"`
}

// IdentifierStatus defines model for identifierStatus.
type IdentifierStatus string

// IdentifierType defines model for identifierType.
type IdentifierType string

// IdentifierUpdateReq defines model for identifierUpdateReq.
type IdentifierUpdateReq struct {
	Status IdentifierStatus `json:"status"`
}

// JavaScriptHighEntropy defines model for javaScriptHighEntropy.
type JavaScriptHighEntropy struct {
	Mobile          bool   `json:"mobile"`
	Platform        string `json:"platform"`
	PlatformVersion string `json:"platformVersion"`
}

// LongSession defines model for longSession.
type LongSession struct {
	Expires         string            `json:"expires"`
	IdentifierValue string            `json:"identifierValue"`
	LongSessionID   string            `json:"longSessionID"`
	Status          LongSessionStatus `json:"status"`
	UserID          string            `json:"userID"`
}

// LongSessionCreateReq defines model for longSessionCreateReq.
type LongSessionCreateReq struct {
	// AppType Application type
	AppType         externalRef0.AppType `json:"appType"`
	IdentifierValue string               `json:"identifierValue"`
}

// LongSessionStatus defines model for longSessionStatus.
type LongSessionStatus string

// LongSessionUpdateReq defines model for longSessionUpdateReq.
type LongSessionUpdateReq struct {
	Status LongSessionStatus `json:"status"`
}

// PasskeyAppendFinishReq defines model for passkeyAppendFinishReq.
type PasskeyAppendFinishReq struct {
	AttestationResponse string            `json:"attestationResponse"`
	ClientInformation   ClientInformation `json:"clientInformation"`
	ProcessID           string            `json:"processID"`
	SendNotification    *bool             `json:"sendNotification,omitempty"`

	// UserID ID of the user
	UserID externalRef0.UserID `json:"userID"`
}

// PasskeyAppendFinishRsp defines model for passkeyAppendFinishRsp.
type PasskeyAppendFinishRsp struct {
	PasskeyData PasskeyData `json:"passkeyData"`
}

// PasskeyAppendStartReq defines model for passkeyAppendStartReq.
type PasskeyAppendStartReq struct {
	ClientInformation ClientInformation `json:"clientInformation"`
	PasskeyIntelFlags PasskeyIntelFlags `json:"passkeyIntelFlags"`
	ProcessID         string            `json:"processID"`

	// UserID ID of the user
	UserID   externalRef0.UserID `json:"userID"`
	Username string              `json:"username"`
}

// PasskeyAppendStartRsp defines model for passkeyAppendStartRsp.
type PasskeyAppendStartRsp struct {
	AppendAllow        bool           `json:"appendAllow"`
	AttestationOptions string         `json:"attestationOptions"`
	CredentialCount    int            `json:"credentialCount"`
	DecisionTag        DecisionTag    `json:"decisionTag"`
	DetectionTags      []DetectionTag `json:"detectionTags"`
}

// PasskeyChallenge defines model for passkeyChallenge.
type PasskeyChallenge struct {
	ChallengeID string                 `json:"challengeID"`
	Created     int64                  `json:"created"`
	Expires     int64                  `json:"expires"`
	Status      PasskeyChallengeStatus `json:"status"`
	Type        PasskeyChallengeType   `json:"type"`
	Value       string                 `json:"value"`
}

// PasskeyChallengeList defines model for passkeyChallengeList.
type PasskeyChallengeList struct {
	Paging            externalRef0.Paging `json:"paging"`
	PasskeyChallenges []PasskeyChallenge  `json:"passkeyChallenges"`
}

// PasskeyChallengeStatus defines model for passkeyChallengeStatus.
type PasskeyChallengeStatus string

// PasskeyChallengeType defines model for passkeyChallengeType.
type PasskeyChallengeType string

// PasskeyChallengeUpdateReq defines model for passkeyChallengeUpdateReq.
type PasskeyChallengeUpdateReq struct {
	Status PasskeyChallengeStatus `json:"status"`
}

// PasskeyData defines model for passkeyData.
type PasskeyData struct {
	CeremonyType PasskeyDataCeremonyType `json:"ceremonyType"`
	ChallengeID  string                  `json:"challengeID"`
	Id           string                  `json:"id"`
	UserID       string                  `json:"userID"`
	Username     string                  `json:"username"`
}

// PasskeyDataCeremonyType defines model for PasskeyData.CeremonyType.
type PasskeyDataCeremonyType string

// PasskeyEvent defines model for passkeyEvent.
type PasskeyEvent struct {
	ClientEnvID *string `json:"clientEnvID,omitempty"`

	// Created Timestamp of when the entity was created in yyyy-MM-dd'T'HH:mm:ss format
	Created        externalRef0.Created `json:"created"`
	CredentialID   *string              `json:"credentialID,omitempty"`
	EventType      PasskeyEventType     `json:"eventType"`
	Expires        *int                 `json:"expires,omitempty"`
	PasskeyEventID string               `json:"passkeyEventID"`
	ProcessID      *string              `json:"processID,omitempty"`

	// UserID ID of the user
	UserID externalRef0.UserID `json:"userID"`
}

// PasskeyEventCreateReq defines model for passkeyEventCreateReq.
type PasskeyEventCreateReq struct {
	ClientEnvID  *string          `json:"clientEnvID,omitempty"`
	CredentialID *string          `json:"credentialID,omitempty"`
	EventType    PasskeyEventType `json:"eventType"`
	Expires      *int             `json:"expires,omitempty"`
	ProcessID    *string          `json:"processID,omitempty"`
}

// PasskeyEventList defines model for passkeyEventList.
type PasskeyEventList struct {
	Paging        externalRef0.Paging `json:"paging"`
	PasskeyEvents []PasskeyEvent      `json:"passkeyEvents"`
}

// PasskeyEventType defines model for passkeyEventType.
type PasskeyEventType string

// PasskeyIntelFlags defines model for passkeyIntelFlags.
type PasskeyIntelFlags struct {
	ForcePasskeyAppend bool `json:"forcePasskeyAppend"`
}

// PasskeyLoginFinishReq defines model for passkeyLoginFinishReq.
type PasskeyLoginFinishReq struct {
	AssertionResponse string            `json:"assertionResponse"`
	ClientInformation ClientInformation `json:"clientInformation"`
	ProcessID         string            `json:"processID"`

	// UserID ID of the user
	UserID externalRef0.UserID `json:"userID"`
}

// PasskeyLoginFinishRsp defines model for passkeyLoginFinishRsp.
type PasskeyLoginFinishRsp struct {
	PasskeyData PasskeyData `json:"passkeyData"`
}

// PasskeyLoginStartReq defines model for passkeyLoginStartReq.
type PasskeyLoginStartReq struct {
	ClientInformation                 ClientInformation                 `json:"clientInformation"`
	CrossDeviceAuthenticationStrategy CrossDeviceAuthenticationStrategy `json:"crossDeviceAuthenticationStrategy"`
	ProcessID                         string                            `json:"processID"`

	// UserID ID of the user
	UserID externalRef0.UserID `json:"userID"`
}

// PasskeyLoginStartRsp defines model for passkeyLoginStartRsp.
type PasskeyLoginStartRsp struct {
	AssertionOptions string         `json:"assertionOptions"`
	CredentialCount  int            `json:"credentialCount"`
	DecisionTag      DecisionTag    `json:"decisionTag"`
	DetectionTags    []DetectionTag `json:"detectionTags"`
	IsCDACandidate   bool           `json:"isCDACandidate"`
	LoginAllow       bool           `json:"loginAllow"`
}

// PasskeyMediationFinishReq defines model for passkeyMediationFinishReq.
type PasskeyMediationFinishReq struct {
	AssertionResponse string            `json:"assertionResponse"`
	ClientInformation ClientInformation `json:"clientInformation"`
	ProcessID         string            `json:"processID"`
}

// PasskeyMediationFinishRsp defines model for passkeyMediationFinishRsp.
type PasskeyMediationFinishRsp struct {
	PasskeyData PasskeyData `json:"passkeyData"`
}

// PasskeyMediationStartReq defines model for passkeyMediationStartReq.
type PasskeyMediationStartReq struct {
	ClientInformation ClientInformation `json:"clientInformation"`
}

// PasskeyMediationStartRsp defines model for passkeyMediationStartRsp.
type PasskeyMediationStartRsp struct {
	AssertionOptions string `json:"assertionOptions"`
	LoginAllow       bool   `json:"loginAllow"`
}

// ProjectConfigUpdateCnameReq defines model for projectConfigUpdateCnameReq.
type ProjectConfigUpdateCnameReq struct {
	Cname string `json:"cname"`
}

// ShortSession defines model for shortSession.
type ShortSession struct {
	Value string `json:"value"`
}

// ShortSessionCreateReq defines model for shortSessionCreateReq.
type ShortSessionCreateReq struct {
	// AppType Application type
	AppType externalRef0.AppType `json:"appType"`
	Issuer  string               `json:"issuer"`
}

// SocialAccount defines model for socialAccount.
type SocialAccount struct {
	AvatarURL       string `json:"avatarURL"`
	ForeignID       string `json:"foreignID"`
	FullName        string `json:"fullName"`
	IdentifierValue string `json:"identifierValue"`
	ProviderType    string `json:"providerType"`
	SocialAccountID string `json:"socialAccountID"`
	UserID          string `json:"userID"`
}

// SocialAccountCreateReq defines model for socialAccountCreateReq.
type SocialAccountCreateReq struct {
	AvatarURL       string                          `json:"avatarURL"`
	ForeignID       string                          `json:"foreignID"`
	FullName        string                          `json:"fullName"`
	IdentifierValue string                          `json:"identifierValue"`
	ProviderType    externalRef0.SocialProviderType `json:"providerType"`
}

// SocialAccountList defines model for socialAccountList.
type SocialAccountList struct {
	Paging         externalRef0.Paging `json:"paging"`
	SocialAccounts []SocialAccount     `json:"socialAccounts"`
}

// User defines model for user.
type User struct {
	ExplicitWebauthnID *string    `json:"explicitWebauthnID,omitempty"`
	FullName           *string    `json:"fullName,omitempty"`
	Status             UserStatus `json:"status"`
	UserID             string     `json:"userID"`
}

// UserCreateReq defines model for userCreateReq.
type UserCreateReq struct {
	// ExplicitWebauthnID For connect projects, the webauthnID can be explicitly set for a user
	ExplicitWebauthnID *string    `json:"explicitWebauthnID,omitempty"`
	FullName           *string    `json:"fullName,omitempty"`
	Status             UserStatus `json:"status"`
}

// UserStatus defines model for userStatus.
type UserStatus string

// UserUpdateReq defines model for userUpdateReq.
type UserUpdateReq struct {
	FullName *string     `json:"fullName,omitempty"`
	Status   *UserStatus `json:"status,omitempty"`
}

// ChallengeID defines model for challengeID.
type ChallengeID = string

// ConnectTokenID defines model for connectTokenID.
type ConnectTokenID = string

// CredentialID defines model for credentialID.
type CredentialID = string

// IdentifierID defines model for identifierID.
type IdentifierID = string

// LongSessionID defines model for longSessionID.
type LongSessionID = string

// PasskeyChallengeID defines model for passkeyChallengeID.
type PasskeyChallengeID = string

// PasskeyEventID defines model for passkeyEventID.
type PasskeyEventID = string

// UserID defines model for userID.
type UserID = string

// N200 defines model for 200.
type N200 = externalRef0.GenericRsp

// Error defines model for error.
type Error = externalRef0.ErrorRsp

// ConnectTokenListParams defines parameters for ConnectTokenList.
type ConnectTokenListParams struct {
	// Sort Field sorting
	Sort *externalRef0.Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// Filter Field filtering
	Filter *externalRef0.Filter `form:"filter[],omitempty" json:"filter[],omitempty"`

	// Page Page number
	Page *externalRef0.Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *externalRef0.PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// IdentifierListParams defines parameters for IdentifierList.
type IdentifierListParams struct {
	// Sort Field sorting
	Sort *externalRef0.Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// Filter Field filtering
	Filter *externalRef0.Filter `form:"filter[],omitempty" json:"filter[],omitempty"`

	// Page Page number
	Page *externalRef0.Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *externalRef0.PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// SocialAccountListParams defines parameters for SocialAccountList.
type SocialAccountListParams struct {
	// Sort Field sorting
	Sort *externalRef0.Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// Filter Field filtering
	Filter *externalRef0.Filter `form:"filter[],omitempty" json:"filter[],omitempty"`

	// Page Page number
	Page *externalRef0.Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *externalRef0.PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// CredentialListParams defines parameters for CredentialList.
type CredentialListParams struct {
	// Sort Field sorting
	Sort *externalRef0.Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// Filter Field filtering
	Filter *externalRef0.Filter `form:"filter[],omitempty" json:"filter[],omitempty"`

	// Page Page number
	Page *externalRef0.Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *externalRef0.PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// PasskeyChallengeListParams defines parameters for PasskeyChallengeList.
type PasskeyChallengeListParams struct {
	// Sort Field sorting
	Sort *externalRef0.Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// Filter Field filtering
	Filter *externalRef0.Filter `form:"filter[],omitempty" json:"filter[],omitempty"`

	// Page Page number
	Page *externalRef0.Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *externalRef0.PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// PasskeyEventListParams defines parameters for PasskeyEventList.
type PasskeyEventListParams struct {
	// Sort Field sorting
	Sort *externalRef0.Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// Filter Field filtering
	Filter *externalRef0.Filter `form:"filter[],omitempty" json:"filter[],omitempty"`

	// Page Page number
	Page *externalRef0.Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *externalRef0.PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// UserSocialAccountListParams defines parameters for UserSocialAccountList.
type UserSocialAccountListParams struct {
	// Sort Field sorting
	Sort *externalRef0.Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// Filter Field filtering
	Filter *externalRef0.Filter `form:"filter[],omitempty" json:"filter[],omitempty"`

	// Page Page number
	Page *externalRef0.Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of items per page
	PageSize *externalRef0.PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// ConnectTokenCreateJSONRequestBody defines body for ConnectTokenCreate for application/json ContentType.
type ConnectTokenCreateJSONRequestBody = ConnectTokenCreateReq

// ConnectTokenUpdateJSONRequestBody defines body for ConnectTokenUpdate for application/json ContentType.
type ConnectTokenUpdateJSONRequestBody = ConnectTokenUpdateReq

// PasskeyAppendFinishJSONRequestBody defines body for PasskeyAppendFinish for application/json ContentType.
type PasskeyAppendFinishJSONRequestBody = PasskeyAppendFinishReq

// PasskeyAppendStartJSONRequestBody defines body for PasskeyAppendStart for application/json ContentType.
type PasskeyAppendStartJSONRequestBody = PasskeyAppendStartReq

// PasskeyLoginFinishJSONRequestBody defines body for PasskeyLoginFinish for application/json ContentType.
type PasskeyLoginFinishJSONRequestBody = PasskeyLoginFinishReq

// PasskeyLoginStartJSONRequestBody defines body for PasskeyLoginStart for application/json ContentType.
type PasskeyLoginStartJSONRequestBody = PasskeyLoginStartReq

// PasskeyMediationFinishJSONRequestBody defines body for PasskeyMediationFinish for application/json ContentType.
type PasskeyMediationFinishJSONRequestBody = PasskeyMediationFinishReq

// PasskeyMediationStartJSONRequestBody defines body for PasskeyMediationStart for application/json ContentType.
type PasskeyMediationStartJSONRequestBody = PasskeyMediationStartReq

// ProjectConfigUpdateCNAMEJSONRequestBody defines body for ProjectConfigUpdateCNAME for application/json ContentType.
type ProjectConfigUpdateCNAMEJSONRequestBody = ProjectConfigUpdateCnameReq

// UserCreateJSONRequestBody defines body for UserCreate for application/json ContentType.
type UserCreateJSONRequestBody = UserCreateReq

// UserUpdateJSONRequestBody defines body for UserUpdate for application/json ContentType.
type UserUpdateJSONRequestBody = UserUpdateReq

// AuthEventCreateJSONRequestBody defines body for AuthEventCreate for application/json ContentType.
type AuthEventCreateJSONRequestBody = AuthEventCreateReq

// ChallengeCreateJSONRequestBody defines body for ChallengeCreate for application/json ContentType.
type ChallengeCreateJSONRequestBody = ChallengeCreateReq

// ChallengeUpdateJSONRequestBody defines body for ChallengeUpdate for application/json ContentType.
type ChallengeUpdateJSONRequestBody = ChallengeUpdateReq

// IdentifierCreateJSONRequestBody defines body for IdentifierCreate for application/json ContentType.
type IdentifierCreateJSONRequestBody = IdentifierCreateReq

// IdentifierUpdateJSONRequestBody defines body for IdentifierUpdate for application/json ContentType.
type IdentifierUpdateJSONRequestBody = IdentifierUpdateReq

// LongSessionCreateJSONRequestBody defines body for LongSessionCreate for application/json ContentType.
type LongSessionCreateJSONRequestBody = LongSessionCreateReq

// LongSessionUpdateJSONRequestBody defines body for LongSessionUpdate for application/json ContentType.
type LongSessionUpdateJSONRequestBody = LongSessionUpdateReq

// ShortSessionCreateJSONRequestBody defines body for ShortSessionCreate for application/json ContentType.
type ShortSessionCreateJSONRequestBody = ShortSessionCreateReq

// PasskeyChallengeUpdateJSONRequestBody defines body for PasskeyChallengeUpdate for application/json ContentType.
type PasskeyChallengeUpdateJSONRequestBody = PasskeyChallengeUpdateReq

// PasskeyEventCreateJSONRequestBody defines body for PasskeyEventCreate for application/json ContentType.
type PasskeyEventCreateJSONRequestBody = PasskeyEventCreateReq

// SocialAccountCreateJSONRequestBody defines body for SocialAccountCreate for application/json ContentType.
type SocialAccountCreateJSONRequestBody = SocialAccountCreateReq

// AsConnectTokenDataPasskeyAppend returns the union data inside the ConnectTokenData as a ConnectTokenDataPasskeyAppend
func (t ConnectTokenData) AsConnectTokenDataPasskeyAppend() (ConnectTokenDataPasskeyAppend, error) {
	var body ConnectTokenDataPasskeyAppend
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectTokenDataPasskeyAppend overwrites any union data inside the ConnectTokenData as the provided ConnectTokenDataPasskeyAppend
func (t *ConnectTokenData) FromConnectTokenDataPasskeyAppend(v ConnectTokenDataPasskeyAppend) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectTokenDataPasskeyAppend performs a merge with any union data inside the ConnectTokenData, using the provided ConnectTokenDataPasskeyAppend
func (t *ConnectTokenData) MergeConnectTokenDataPasskeyAppend(v ConnectTokenDataPasskeyAppend) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectTokenDataPasskeyDelete returns the union data inside the ConnectTokenData as a ConnectTokenDataPasskeyDelete
func (t ConnectTokenData) AsConnectTokenDataPasskeyDelete() (ConnectTokenDataPasskeyDelete, error) {
	var body ConnectTokenDataPasskeyDelete
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectTokenDataPasskeyDelete overwrites any union data inside the ConnectTokenData as the provided ConnectTokenDataPasskeyDelete
func (t *ConnectTokenData) FromConnectTokenDataPasskeyDelete(v ConnectTokenDataPasskeyDelete) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectTokenDataPasskeyDelete performs a merge with any union data inside the ConnectTokenData, using the provided ConnectTokenDataPasskeyDelete
func (t *ConnectTokenData) MergeConnectTokenDataPasskeyDelete(v ConnectTokenDataPasskeyDelete) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectTokenDataPasskeyList returns the union data inside the ConnectTokenData as a ConnectTokenDataPasskeyList
func (t ConnectTokenData) AsConnectTokenDataPasskeyList() (ConnectTokenDataPasskeyList, error) {
	var body ConnectTokenDataPasskeyList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectTokenDataPasskeyList overwrites any union data inside the ConnectTokenData as the provided ConnectTokenDataPasskeyList
func (t *ConnectTokenData) FromConnectTokenDataPasskeyList(v ConnectTokenDataPasskeyList) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectTokenDataPasskeyList performs a merge with any union data inside the ConnectTokenData, using the provided ConnectTokenDataPasskeyList
func (t *ConnectTokenData) MergeConnectTokenDataPasskeyList(v ConnectTokenDataPasskeyList) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConnectTokenData) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConnectTokenData) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ConnectTokenList request
	ConnectTokenList(ctx context.Context, params *ConnectTokenListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectTokenCreateWithBody request with any body
	ConnectTokenCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectTokenCreate(ctx context.Context, body ConnectTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectTokenDelete request
	ConnectTokenDelete(ctx context.Context, connectTokenID ConnectTokenID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConnectTokenUpdateWithBody request with any body
	ConnectTokenUpdateWithBody(ctx context.Context, connectTokenID ConnectTokenID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConnectTokenUpdate(ctx context.Context, connectTokenID ConnectTokenID, body ConnectTokenUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdentifierList request
	IdentifierList(ctx context.Context, params *IdentifierListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LongSessionGet request
	LongSessionGet(ctx context.Context, longSessionID LongSessionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeyAppendFinishWithBody request with any body
	PasskeyAppendFinishWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeyAppendFinish(ctx context.Context, body PasskeyAppendFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeyAppendStartWithBody request with any body
	PasskeyAppendStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeyAppendStart(ctx context.Context, body PasskeyAppendStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeyLoginFinishWithBody request with any body
	PasskeyLoginFinishWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeyLoginFinish(ctx context.Context, body PasskeyLoginFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeyLoginStartWithBody request with any body
	PasskeyLoginStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeyLoginStart(ctx context.Context, body PasskeyLoginStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeyMediationFinishWithBody request with any body
	PasskeyMediationFinishWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeyMediationFinish(ctx context.Context, body PasskeyMediationFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeyMediationStartWithBody request with any body
	PasskeyMediationStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeyMediationStart(ctx context.Context, body PasskeyMediationStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectConfigUpdateCNAMEWithBody request with any body
	ProjectConfigUpdateCNAMEWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectConfigUpdateCNAME(ctx context.Context, body ProjectConfigUpdateCNAMEJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SocialAccountList request
	SocialAccountList(ctx context.Context, params *SocialAccountListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserCreateWithBody request with any body
	UserCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserCreate(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserDelete request
	UserDelete(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserGet request
	UserGet(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateWithBody request with any body
	UserUpdateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserUpdate(ctx context.Context, userID UserID, body UserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthEventCreateWithBody request with any body
	AuthEventCreateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthEventCreate(ctx context.Context, userID UserID, body AuthEventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChallengeCreateWithBody request with any body
	ChallengeCreateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChallengeCreate(ctx context.Context, userID UserID, body ChallengeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChallengeUpdateWithBody request with any body
	ChallengeUpdateWithBody(ctx context.Context, userID UserID, challengeID ChallengeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChallengeUpdate(ctx context.Context, userID UserID, challengeID ChallengeID, body ChallengeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CredentialList request
	CredentialList(ctx context.Context, userID UserID, params *CredentialListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CredentialDelete request
	CredentialDelete(ctx context.Context, userID UserID, credentialID CredentialID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdentifierCreateWithBody request with any body
	IdentifierCreateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IdentifierCreate(ctx context.Context, userID UserID, body IdentifierCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdentifierDelete request
	IdentifierDelete(ctx context.Context, userID UserID, identifierID IdentifierID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IdentifierUpdateWithBody request with any body
	IdentifierUpdateWithBody(ctx context.Context, userID UserID, identifierID IdentifierID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IdentifierUpdate(ctx context.Context, userID UserID, identifierID IdentifierID, body IdentifierUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LongSessionCreateWithBody request with any body
	LongSessionCreateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LongSessionCreate(ctx context.Context, userID UserID, body LongSessionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserLongSessionGet request
	UserLongSessionGet(ctx context.Context, userID UserID, longSessionID LongSessionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LongSessionUpdateWithBody request with any body
	LongSessionUpdateWithBody(ctx context.Context, userID UserID, longSessionID LongSessionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LongSessionUpdate(ctx context.Context, userID UserID, longSessionID LongSessionID, body LongSessionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShortSessionCreateWithBody request with any body
	ShortSessionCreateWithBody(ctx context.Context, userID UserID, longSessionID LongSessionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ShortSessionCreate(ctx context.Context, userID UserID, longSessionID LongSessionID, body ShortSessionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeyChallengeList request
	PasskeyChallengeList(ctx context.Context, userID UserID, params *PasskeyChallengeListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeyChallengeUpdateWithBody request with any body
	PasskeyChallengeUpdateWithBody(ctx context.Context, userID UserID, passkeyChallengeID PasskeyChallengeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeyChallengeUpdate(ctx context.Context, userID UserID, passkeyChallengeID PasskeyChallengeID, body PasskeyChallengeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeyEventList request
	PasskeyEventList(ctx context.Context, userID UserID, params *PasskeyEventListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeyEventCreateWithBody request with any body
	PasskeyEventCreateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PasskeyEventCreate(ctx context.Context, userID UserID, body PasskeyEventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PasskeyEventDelete request
	PasskeyEventDelete(ctx context.Context, userID UserID, passkeyEventID PasskeyEventID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserSocialAccountList request
	UserSocialAccountList(ctx context.Context, userID UserID, params *UserSocialAccountListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SocialAccountCreateWithBody request with any body
	SocialAccountCreateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SocialAccountCreate(ctx context.Context, userID UserID, body SocialAccountCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ConnectTokenList(ctx context.Context, params *ConnectTokenListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectTokenListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectTokenCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectTokenCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectTokenCreate(ctx context.Context, body ConnectTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectTokenCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectTokenDelete(ctx context.Context, connectTokenID ConnectTokenID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectTokenDeleteRequest(c.Server, connectTokenID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectTokenUpdateWithBody(ctx context.Context, connectTokenID ConnectTokenID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectTokenUpdateRequestWithBody(c.Server, connectTokenID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConnectTokenUpdate(ctx context.Context, connectTokenID ConnectTokenID, body ConnectTokenUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConnectTokenUpdateRequest(c.Server, connectTokenID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdentifierList(ctx context.Context, params *IdentifierListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdentifierListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LongSessionGet(ctx context.Context, longSessionID LongSessionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLongSessionGetRequest(c.Server, longSessionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyAppendFinishWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyAppendFinishRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyAppendFinish(ctx context.Context, body PasskeyAppendFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyAppendFinishRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyAppendStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyAppendStartRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyAppendStart(ctx context.Context, body PasskeyAppendStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyAppendStartRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyLoginFinishWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyLoginFinishRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyLoginFinish(ctx context.Context, body PasskeyLoginFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyLoginFinishRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyLoginStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyLoginStartRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyLoginStart(ctx context.Context, body PasskeyLoginStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyLoginStartRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyMediationFinishWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyMediationFinishRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyMediationFinish(ctx context.Context, body PasskeyMediationFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyMediationFinishRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyMediationStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyMediationStartRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyMediationStart(ctx context.Context, body PasskeyMediationStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyMediationStartRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectConfigUpdateCNAMEWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectConfigUpdateCNAMERequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectConfigUpdateCNAME(ctx context.Context, body ProjectConfigUpdateCNAMEJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectConfigUpdateCNAMERequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialAccountList(ctx context.Context, params *SocialAccountListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialAccountListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserCreate(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserDelete(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserDeleteRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserGet(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserGetRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdate(ctx context.Context, userID UserID, body UserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthEventCreateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthEventCreateRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthEventCreate(ctx context.Context, userID UserID, body AuthEventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthEventCreateRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChallengeCreateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChallengeCreateRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChallengeCreate(ctx context.Context, userID UserID, body ChallengeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChallengeCreateRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChallengeUpdateWithBody(ctx context.Context, userID UserID, challengeID ChallengeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChallengeUpdateRequestWithBody(c.Server, userID, challengeID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChallengeUpdate(ctx context.Context, userID UserID, challengeID ChallengeID, body ChallengeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChallengeUpdateRequest(c.Server, userID, challengeID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CredentialList(ctx context.Context, userID UserID, params *CredentialListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialListRequest(c.Server, userID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CredentialDelete(ctx context.Context, userID UserID, credentialID CredentialID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialDeleteRequest(c.Server, userID, credentialID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdentifierCreateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdentifierCreateRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdentifierCreate(ctx context.Context, userID UserID, body IdentifierCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdentifierCreateRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdentifierDelete(ctx context.Context, userID UserID, identifierID IdentifierID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdentifierDeleteRequest(c.Server, userID, identifierID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdentifierUpdateWithBody(ctx context.Context, userID UserID, identifierID IdentifierID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdentifierUpdateRequestWithBody(c.Server, userID, identifierID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IdentifierUpdate(ctx context.Context, userID UserID, identifierID IdentifierID, body IdentifierUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIdentifierUpdateRequest(c.Server, userID, identifierID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LongSessionCreateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLongSessionCreateRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LongSessionCreate(ctx context.Context, userID UserID, body LongSessionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLongSessionCreateRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserLongSessionGet(ctx context.Context, userID UserID, longSessionID LongSessionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserLongSessionGetRequest(c.Server, userID, longSessionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LongSessionUpdateWithBody(ctx context.Context, userID UserID, longSessionID LongSessionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLongSessionUpdateRequestWithBody(c.Server, userID, longSessionID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LongSessionUpdate(ctx context.Context, userID UserID, longSessionID LongSessionID, body LongSessionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLongSessionUpdateRequest(c.Server, userID, longSessionID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShortSessionCreateWithBody(ctx context.Context, userID UserID, longSessionID LongSessionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShortSessionCreateRequestWithBody(c.Server, userID, longSessionID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShortSessionCreate(ctx context.Context, userID UserID, longSessionID LongSessionID, body ShortSessionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShortSessionCreateRequest(c.Server, userID, longSessionID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyChallengeList(ctx context.Context, userID UserID, params *PasskeyChallengeListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyChallengeListRequest(c.Server, userID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyChallengeUpdateWithBody(ctx context.Context, userID UserID, passkeyChallengeID PasskeyChallengeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyChallengeUpdateRequestWithBody(c.Server, userID, passkeyChallengeID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyChallengeUpdate(ctx context.Context, userID UserID, passkeyChallengeID PasskeyChallengeID, body PasskeyChallengeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyChallengeUpdateRequest(c.Server, userID, passkeyChallengeID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyEventList(ctx context.Context, userID UserID, params *PasskeyEventListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyEventListRequest(c.Server, userID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyEventCreateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyEventCreateRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyEventCreate(ctx context.Context, userID UserID, body PasskeyEventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyEventCreateRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PasskeyEventDelete(ctx context.Context, userID UserID, passkeyEventID PasskeyEventID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPasskeyEventDeleteRequest(c.Server, userID, passkeyEventID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserSocialAccountList(ctx context.Context, userID UserID, params *UserSocialAccountListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserSocialAccountListRequest(c.Server, userID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialAccountCreateWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialAccountCreateRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SocialAccountCreate(ctx context.Context, userID UserID, body SocialAccountCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSocialAccountCreateRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewConnectTokenListRequest generates requests for ConnectTokenList
func NewConnectTokenListRequest(server string, params *ConnectTokenListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectTokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[]", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConnectTokenCreateRequest calls the generic ConnectTokenCreate builder with application/json body
func NewConnectTokenCreateRequest(server string, body ConnectTokenCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectTokenCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewConnectTokenCreateRequestWithBody generates requests for ConnectTokenCreate with any type of body
func NewConnectTokenCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectTokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConnectTokenDeleteRequest generates requests for ConnectTokenDelete
func NewConnectTokenDeleteRequest(server string, connectTokenID ConnectTokenID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectTokenID", runtime.ParamLocationPath, connectTokenID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectTokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConnectTokenUpdateRequest calls the generic ConnectTokenUpdate builder with application/json body
func NewConnectTokenUpdateRequest(server string, connectTokenID ConnectTokenID, body ConnectTokenUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConnectTokenUpdateRequestWithBody(server, connectTokenID, "application/json", bodyReader)
}

// NewConnectTokenUpdateRequestWithBody generates requests for ConnectTokenUpdate with any type of body
func NewConnectTokenUpdateRequestWithBody(server string, connectTokenID ConnectTokenID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "connectTokenID", runtime.ParamLocationPath, connectTokenID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connectTokens/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIdentifierListRequest generates requests for IdentifierList
func NewIdentifierListRequest(server string, params *IdentifierListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/identifiers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[]", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLongSessionGetRequest generates requests for LongSessionGet
func NewLongSessionGetRequest(server string, longSessionID LongSessionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "longSessionID", runtime.ParamLocationPath, longSessionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/longSessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasskeyAppendFinishRequest calls the generic PasskeyAppendFinish builder with application/json body
func NewPasskeyAppendFinishRequest(server string, body PasskeyAppendFinishJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeyAppendFinishRequestWithBody(server, "application/json", bodyReader)
}

// NewPasskeyAppendFinishRequestWithBody generates requests for PasskeyAppendFinish with any type of body
func NewPasskeyAppendFinishRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/passkey/append/finish")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeyAppendStartRequest calls the generic PasskeyAppendStart builder with application/json body
func NewPasskeyAppendStartRequest(server string, body PasskeyAppendStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeyAppendStartRequestWithBody(server, "application/json", bodyReader)
}

// NewPasskeyAppendStartRequestWithBody generates requests for PasskeyAppendStart with any type of body
func NewPasskeyAppendStartRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/passkey/append/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeyLoginFinishRequest calls the generic PasskeyLoginFinish builder with application/json body
func NewPasskeyLoginFinishRequest(server string, body PasskeyLoginFinishJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeyLoginFinishRequestWithBody(server, "application/json", bodyReader)
}

// NewPasskeyLoginFinishRequestWithBody generates requests for PasskeyLoginFinish with any type of body
func NewPasskeyLoginFinishRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/passkey/login/finish")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeyLoginStartRequest calls the generic PasskeyLoginStart builder with application/json body
func NewPasskeyLoginStartRequest(server string, body PasskeyLoginStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeyLoginStartRequestWithBody(server, "application/json", bodyReader)
}

// NewPasskeyLoginStartRequestWithBody generates requests for PasskeyLoginStart with any type of body
func NewPasskeyLoginStartRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/passkey/login/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeyMediationFinishRequest calls the generic PasskeyMediationFinish builder with application/json body
func NewPasskeyMediationFinishRequest(server string, body PasskeyMediationFinishJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeyMediationFinishRequestWithBody(server, "application/json", bodyReader)
}

// NewPasskeyMediationFinishRequestWithBody generates requests for PasskeyMediationFinish with any type of body
func NewPasskeyMediationFinishRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/passkey/mediation/finish")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeyMediationStartRequest calls the generic PasskeyMediationStart builder with application/json body
func NewPasskeyMediationStartRequest(server string, body PasskeyMediationStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeyMediationStartRequestWithBody(server, "application/json", bodyReader)
}

// NewPasskeyMediationStartRequestWithBody generates requests for PasskeyMediationStart with any type of body
func NewPasskeyMediationStartRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/passkey/mediation/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectConfigUpdateCNAMERequest calls the generic ProjectConfigUpdateCNAME builder with application/json body
func NewProjectConfigUpdateCNAMERequest(server string, body ProjectConfigUpdateCNAMEJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectConfigUpdateCNAMERequestWithBody(server, "application/json", bodyReader)
}

// NewProjectConfigUpdateCNAMERequestWithBody generates requests for ProjectConfigUpdateCNAME with any type of body
func NewProjectConfigUpdateCNAMERequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projectConfig/cname")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSocialAccountListRequest generates requests for SocialAccountList
func NewSocialAccountListRequest(server string, params *SocialAccountListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/socialAccounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[]", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserCreateRequest calls the generic UserCreate builder with application/json body
func NewUserCreateRequest(server string, body UserCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewUserCreateRequestWithBody generates requests for UserCreate with any type of body
func NewUserCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserDeleteRequest generates requests for UserDelete
func NewUserDeleteRequest(server string, userID UserID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserGetRequest generates requests for UserGet
func NewUserGetRequest(server string, userID UserID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateRequest calls the generic UserUpdate builder with application/json body
func NewUserUpdateRequest(server string, userID UserID, body UserUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserUpdateRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewUserUpdateRequestWithBody generates requests for UserUpdate with any type of body
func NewUserUpdateRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthEventCreateRequest calls the generic AuthEventCreate builder with application/json body
func NewAuthEventCreateRequest(server string, userID UserID, body AuthEventCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthEventCreateRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewAuthEventCreateRequestWithBody generates requests for AuthEventCreate with any type of body
func NewAuthEventCreateRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/authEvents", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChallengeCreateRequest calls the generic ChallengeCreate builder with application/json body
func NewChallengeCreateRequest(server string, userID UserID, body ChallengeCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChallengeCreateRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewChallengeCreateRequestWithBody generates requests for ChallengeCreate with any type of body
func NewChallengeCreateRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/challenges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChallengeUpdateRequest calls the generic ChallengeUpdate builder with application/json body
func NewChallengeUpdateRequest(server string, userID UserID, challengeID ChallengeID, body ChallengeUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChallengeUpdateRequestWithBody(server, userID, challengeID, "application/json", bodyReader)
}

// NewChallengeUpdateRequestWithBody generates requests for ChallengeUpdate with any type of body
func NewChallengeUpdateRequestWithBody(server string, userID UserID, challengeID ChallengeID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "challengeID", runtime.ParamLocationPath, challengeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/challenges/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCredentialListRequest generates requests for CredentialList
func NewCredentialListRequest(server string, userID UserID, params *CredentialListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[]", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCredentialDeleteRequest generates requests for CredentialDelete
func NewCredentialDeleteRequest(server string, userID UserID, credentialID CredentialID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "credentialID", runtime.ParamLocationPath, credentialID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdentifierCreateRequest calls the generic IdentifierCreate builder with application/json body
func NewIdentifierCreateRequest(server string, userID UserID, body IdentifierCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIdentifierCreateRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewIdentifierCreateRequestWithBody generates requests for IdentifierCreate with any type of body
func NewIdentifierCreateRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/identifiers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIdentifierDeleteRequest generates requests for IdentifierDelete
func NewIdentifierDeleteRequest(server string, userID UserID, identifierID IdentifierID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "identifierID", runtime.ParamLocationPath, identifierID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/identifiers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIdentifierUpdateRequest calls the generic IdentifierUpdate builder with application/json body
func NewIdentifierUpdateRequest(server string, userID UserID, identifierID IdentifierID, body IdentifierUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIdentifierUpdateRequestWithBody(server, userID, identifierID, "application/json", bodyReader)
}

// NewIdentifierUpdateRequestWithBody generates requests for IdentifierUpdate with any type of body
func NewIdentifierUpdateRequestWithBody(server string, userID UserID, identifierID IdentifierID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "identifierID", runtime.ParamLocationPath, identifierID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/identifiers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLongSessionCreateRequest calls the generic LongSessionCreate builder with application/json body
func NewLongSessionCreateRequest(server string, userID UserID, body LongSessionCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLongSessionCreateRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewLongSessionCreateRequestWithBody generates requests for LongSessionCreate with any type of body
func NewLongSessionCreateRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/longSessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserLongSessionGetRequest generates requests for UserLongSessionGet
func NewUserLongSessionGetRequest(server string, userID UserID, longSessionID LongSessionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "longSessionID", runtime.ParamLocationPath, longSessionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/longSessions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLongSessionUpdateRequest calls the generic LongSessionUpdate builder with application/json body
func NewLongSessionUpdateRequest(server string, userID UserID, longSessionID LongSessionID, body LongSessionUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLongSessionUpdateRequestWithBody(server, userID, longSessionID, "application/json", bodyReader)
}

// NewLongSessionUpdateRequestWithBody generates requests for LongSessionUpdate with any type of body
func NewLongSessionUpdateRequestWithBody(server string, userID UserID, longSessionID LongSessionID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "longSessionID", runtime.ParamLocationPath, longSessionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/longSessions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShortSessionCreateRequest calls the generic ShortSessionCreate builder with application/json body
func NewShortSessionCreateRequest(server string, userID UserID, longSessionID LongSessionID, body ShortSessionCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShortSessionCreateRequestWithBody(server, userID, longSessionID, "application/json", bodyReader)
}

// NewShortSessionCreateRequestWithBody generates requests for ShortSessionCreate with any type of body
func NewShortSessionCreateRequestWithBody(server string, userID UserID, longSessionID LongSessionID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "longSessionID", runtime.ParamLocationPath, longSessionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/longSessions/%s/shortSessions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeyChallengeListRequest generates requests for PasskeyChallengeList
func NewPasskeyChallengeListRequest(server string, userID UserID, params *PasskeyChallengeListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/passkeyChallenges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[]", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasskeyChallengeUpdateRequest calls the generic PasskeyChallengeUpdate builder with application/json body
func NewPasskeyChallengeUpdateRequest(server string, userID UserID, passkeyChallengeID PasskeyChallengeID, body PasskeyChallengeUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeyChallengeUpdateRequestWithBody(server, userID, passkeyChallengeID, "application/json", bodyReader)
}

// NewPasskeyChallengeUpdateRequestWithBody generates requests for PasskeyChallengeUpdate with any type of body
func NewPasskeyChallengeUpdateRequestWithBody(server string, userID UserID, passkeyChallengeID PasskeyChallengeID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "passkeyChallengeID", runtime.ParamLocationPath, passkeyChallengeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/passkeyChallenges/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeyEventListRequest generates requests for PasskeyEventList
func NewPasskeyEventListRequest(server string, userID UserID, params *PasskeyEventListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/passkeyEvents", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[]", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPasskeyEventCreateRequest calls the generic PasskeyEventCreate builder with application/json body
func NewPasskeyEventCreateRequest(server string, userID UserID, body PasskeyEventCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPasskeyEventCreateRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewPasskeyEventCreateRequestWithBody generates requests for PasskeyEventCreate with any type of body
func NewPasskeyEventCreateRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/passkeyEvents", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPasskeyEventDeleteRequest generates requests for PasskeyEventDelete
func NewPasskeyEventDeleteRequest(server string, userID UserID, passkeyEventID PasskeyEventID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "passkeyEventID", runtime.ParamLocationPath, passkeyEventID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/passkeyEvents/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserSocialAccountListRequest generates requests for UserSocialAccountList
func NewUserSocialAccountListRequest(server string, userID UserID, params *UserSocialAccountListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/socialAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[]", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSocialAccountCreateRequest calls the generic SocialAccountCreate builder with application/json body
func NewSocialAccountCreateRequest(server string, userID UserID, body SocialAccountCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSocialAccountCreateRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewSocialAccountCreateRequestWithBody generates requests for SocialAccountCreate with any type of body
func NewSocialAccountCreateRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userID", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/socialAccounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ConnectTokenListWithResponse request
	ConnectTokenListWithResponse(ctx context.Context, params *ConnectTokenListParams, reqEditors ...RequestEditorFn) (*ConnectTokenListResponse, error)

	// ConnectTokenCreateWithBodyWithResponse request with any body
	ConnectTokenCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectTokenCreateResponse, error)

	ConnectTokenCreateWithResponse(ctx context.Context, body ConnectTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectTokenCreateResponse, error)

	// ConnectTokenDeleteWithResponse request
	ConnectTokenDeleteWithResponse(ctx context.Context, connectTokenID ConnectTokenID, reqEditors ...RequestEditorFn) (*ConnectTokenDeleteResponse, error)

	// ConnectTokenUpdateWithBodyWithResponse request with any body
	ConnectTokenUpdateWithBodyWithResponse(ctx context.Context, connectTokenID ConnectTokenID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectTokenUpdateResponse, error)

	ConnectTokenUpdateWithResponse(ctx context.Context, connectTokenID ConnectTokenID, body ConnectTokenUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectTokenUpdateResponse, error)

	// IdentifierListWithResponse request
	IdentifierListWithResponse(ctx context.Context, params *IdentifierListParams, reqEditors ...RequestEditorFn) (*IdentifierListResponse, error)

	// LongSessionGetWithResponse request
	LongSessionGetWithResponse(ctx context.Context, longSessionID LongSessionID, reqEditors ...RequestEditorFn) (*LongSessionGetResponse, error)

	// PasskeyAppendFinishWithBodyWithResponse request with any body
	PasskeyAppendFinishWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyAppendFinishResponse, error)

	PasskeyAppendFinishWithResponse(ctx context.Context, body PasskeyAppendFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyAppendFinishResponse, error)

	// PasskeyAppendStartWithBodyWithResponse request with any body
	PasskeyAppendStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyAppendStartResponse, error)

	PasskeyAppendStartWithResponse(ctx context.Context, body PasskeyAppendStartJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyAppendStartResponse, error)

	// PasskeyLoginFinishWithBodyWithResponse request with any body
	PasskeyLoginFinishWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyLoginFinishResponse, error)

	PasskeyLoginFinishWithResponse(ctx context.Context, body PasskeyLoginFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyLoginFinishResponse, error)

	// PasskeyLoginStartWithBodyWithResponse request with any body
	PasskeyLoginStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyLoginStartResponse, error)

	PasskeyLoginStartWithResponse(ctx context.Context, body PasskeyLoginStartJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyLoginStartResponse, error)

	// PasskeyMediationFinishWithBodyWithResponse request with any body
	PasskeyMediationFinishWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyMediationFinishResponse, error)

	PasskeyMediationFinishWithResponse(ctx context.Context, body PasskeyMediationFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyMediationFinishResponse, error)

	// PasskeyMediationStartWithBodyWithResponse request with any body
	PasskeyMediationStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyMediationStartResponse, error)

	PasskeyMediationStartWithResponse(ctx context.Context, body PasskeyMediationStartJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyMediationStartResponse, error)

	// ProjectConfigUpdateCNAMEWithBodyWithResponse request with any body
	ProjectConfigUpdateCNAMEWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectConfigUpdateCNAMEResponse, error)

	ProjectConfigUpdateCNAMEWithResponse(ctx context.Context, body ProjectConfigUpdateCNAMEJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectConfigUpdateCNAMEResponse, error)

	// SocialAccountListWithResponse request
	SocialAccountListWithResponse(ctx context.Context, params *SocialAccountListParams, reqEditors ...RequestEditorFn) (*SocialAccountListResponse, error)

	// UserCreateWithBodyWithResponse request with any body
	UserCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserCreateResponse, error)

	UserCreateWithResponse(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserCreateResponse, error)

	// UserDeleteWithResponse request
	UserDeleteWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*UserDeleteResponse, error)

	// UserGetWithResponse request
	UserGetWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*UserGetResponse, error)

	// UserUpdateWithBodyWithResponse request with any body
	UserUpdateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateResponse, error)

	UserUpdateWithResponse(ctx context.Context, userID UserID, body UserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateResponse, error)

	// AuthEventCreateWithBodyWithResponse request with any body
	AuthEventCreateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthEventCreateResponse, error)

	AuthEventCreateWithResponse(ctx context.Context, userID UserID, body AuthEventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthEventCreateResponse, error)

	// ChallengeCreateWithBodyWithResponse request with any body
	ChallengeCreateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChallengeCreateResponse, error)

	ChallengeCreateWithResponse(ctx context.Context, userID UserID, body ChallengeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChallengeCreateResponse, error)

	// ChallengeUpdateWithBodyWithResponse request with any body
	ChallengeUpdateWithBodyWithResponse(ctx context.Context, userID UserID, challengeID ChallengeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChallengeUpdateResponse, error)

	ChallengeUpdateWithResponse(ctx context.Context, userID UserID, challengeID ChallengeID, body ChallengeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChallengeUpdateResponse, error)

	// CredentialListWithResponse request
	CredentialListWithResponse(ctx context.Context, userID UserID, params *CredentialListParams, reqEditors ...RequestEditorFn) (*CredentialListResponse, error)

	// CredentialDeleteWithResponse request
	CredentialDeleteWithResponse(ctx context.Context, userID UserID, credentialID CredentialID, reqEditors ...RequestEditorFn) (*CredentialDeleteResponse, error)

	// IdentifierCreateWithBodyWithResponse request with any body
	IdentifierCreateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IdentifierCreateResponse, error)

	IdentifierCreateWithResponse(ctx context.Context, userID UserID, body IdentifierCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IdentifierCreateResponse, error)

	// IdentifierDeleteWithResponse request
	IdentifierDeleteWithResponse(ctx context.Context, userID UserID, identifierID IdentifierID, reqEditors ...RequestEditorFn) (*IdentifierDeleteResponse, error)

	// IdentifierUpdateWithBodyWithResponse request with any body
	IdentifierUpdateWithBodyWithResponse(ctx context.Context, userID UserID, identifierID IdentifierID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IdentifierUpdateResponse, error)

	IdentifierUpdateWithResponse(ctx context.Context, userID UserID, identifierID IdentifierID, body IdentifierUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*IdentifierUpdateResponse, error)

	// LongSessionCreateWithBodyWithResponse request with any body
	LongSessionCreateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LongSessionCreateResponse, error)

	LongSessionCreateWithResponse(ctx context.Context, userID UserID, body LongSessionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*LongSessionCreateResponse, error)

	// UserLongSessionGetWithResponse request
	UserLongSessionGetWithResponse(ctx context.Context, userID UserID, longSessionID LongSessionID, reqEditors ...RequestEditorFn) (*UserLongSessionGetResponse, error)

	// LongSessionUpdateWithBodyWithResponse request with any body
	LongSessionUpdateWithBodyWithResponse(ctx context.Context, userID UserID, longSessionID LongSessionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LongSessionUpdateResponse, error)

	LongSessionUpdateWithResponse(ctx context.Context, userID UserID, longSessionID LongSessionID, body LongSessionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LongSessionUpdateResponse, error)

	// ShortSessionCreateWithBodyWithResponse request with any body
	ShortSessionCreateWithBodyWithResponse(ctx context.Context, userID UserID, longSessionID LongSessionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShortSessionCreateResponse, error)

	ShortSessionCreateWithResponse(ctx context.Context, userID UserID, longSessionID LongSessionID, body ShortSessionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ShortSessionCreateResponse, error)

	// PasskeyChallengeListWithResponse request
	PasskeyChallengeListWithResponse(ctx context.Context, userID UserID, params *PasskeyChallengeListParams, reqEditors ...RequestEditorFn) (*PasskeyChallengeListResponse, error)

	// PasskeyChallengeUpdateWithBodyWithResponse request with any body
	PasskeyChallengeUpdateWithBodyWithResponse(ctx context.Context, userID UserID, passkeyChallengeID PasskeyChallengeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyChallengeUpdateResponse, error)

	PasskeyChallengeUpdateWithResponse(ctx context.Context, userID UserID, passkeyChallengeID PasskeyChallengeID, body PasskeyChallengeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyChallengeUpdateResponse, error)

	// PasskeyEventListWithResponse request
	PasskeyEventListWithResponse(ctx context.Context, userID UserID, params *PasskeyEventListParams, reqEditors ...RequestEditorFn) (*PasskeyEventListResponse, error)

	// PasskeyEventCreateWithBodyWithResponse request with any body
	PasskeyEventCreateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyEventCreateResponse, error)

	PasskeyEventCreateWithResponse(ctx context.Context, userID UserID, body PasskeyEventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyEventCreateResponse, error)

	// PasskeyEventDeleteWithResponse request
	PasskeyEventDeleteWithResponse(ctx context.Context, userID UserID, passkeyEventID PasskeyEventID, reqEditors ...RequestEditorFn) (*PasskeyEventDeleteResponse, error)

	// UserSocialAccountListWithResponse request
	UserSocialAccountListWithResponse(ctx context.Context, userID UserID, params *UserSocialAccountListParams, reqEditors ...RequestEditorFn) (*UserSocialAccountListResponse, error)

	// SocialAccountCreateWithBodyWithResponse request with any body
	SocialAccountCreateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SocialAccountCreateResponse, error)

	SocialAccountCreateWithResponse(ctx context.Context, userID UserID, body SocialAccountCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SocialAccountCreateResponse, error)
}

type ConnectTokenListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectTokenList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ConnectTokenListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectTokenListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectTokenCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectToken
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ConnectTokenCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectTokenCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectTokenDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *N200
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ConnectTokenDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectTokenDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConnectTokenUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *N200
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ConnectTokenUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConnectTokenUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdentifierListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IdentifierList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r IdentifierListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdentifierListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LongSessionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LongSession
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LongSessionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LongSessionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeyAppendFinishResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasskeyAppendFinishRsp
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PasskeyAppendFinishResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeyAppendFinishResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeyAppendStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasskeyAppendStartRsp
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PasskeyAppendStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeyAppendStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeyLoginFinishResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasskeyLoginFinishRsp
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PasskeyLoginFinishResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeyLoginFinishResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeyLoginStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasskeyLoginStartRsp
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PasskeyLoginStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeyLoginStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeyMediationFinishResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasskeyMediationFinishRsp
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PasskeyMediationFinishResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeyMediationFinishResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeyMediationStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasskeyMediationStartRsp
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PasskeyMediationStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeyMediationStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectConfigUpdateCNAMEResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *N200
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ProjectConfigUpdateCNAMEResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectConfigUpdateCNAMEResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SocialAccountListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SocialAccountList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SocialAccountListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SocialAccountListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UserCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *N200
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UserDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UserGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UserUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthEventCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthEvent
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AuthEventCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthEventCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChallengeCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Challenge
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ChallengeCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChallengeCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChallengeUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Challenge
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ChallengeUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChallengeUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CredentialListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CredentialListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CredentialListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CredentialDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *N200
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CredentialDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CredentialDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdentifierCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Identifier
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r IdentifierCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdentifierCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdentifierDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *N200
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r IdentifierDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdentifierDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IdentifierUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Identifier
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r IdentifierUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IdentifierUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LongSessionCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LongSession
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LongSessionCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LongSessionCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserLongSessionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LongSession
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UserLongSessionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserLongSessionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LongSessionUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LongSession
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LongSessionUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LongSessionUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShortSessionCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ShortSession
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ShortSessionCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShortSessionCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeyChallengeListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasskeyChallengeList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PasskeyChallengeListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeyChallengeListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeyChallengeUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasskeyChallenge
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PasskeyChallengeUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeyChallengeUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeyEventListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasskeyEventList
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PasskeyEventListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeyEventListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeyEventCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasskeyEvent
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PasskeyEventCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeyEventCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PasskeyEventDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *N200
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PasskeyEventDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PasskeyEventDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserSocialAccountListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SocialAccount
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UserSocialAccountListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserSocialAccountListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SocialAccountCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SocialAccount
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SocialAccountCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SocialAccountCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ConnectTokenListWithResponse request returning *ConnectTokenListResponse
func (c *ClientWithResponses) ConnectTokenListWithResponse(ctx context.Context, params *ConnectTokenListParams, reqEditors ...RequestEditorFn) (*ConnectTokenListResponse, error) {
	rsp, err := c.ConnectTokenList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectTokenListResponse(rsp)
}

// ConnectTokenCreateWithBodyWithResponse request with arbitrary body returning *ConnectTokenCreateResponse
func (c *ClientWithResponses) ConnectTokenCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectTokenCreateResponse, error) {
	rsp, err := c.ConnectTokenCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectTokenCreateResponse(rsp)
}

func (c *ClientWithResponses) ConnectTokenCreateWithResponse(ctx context.Context, body ConnectTokenCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectTokenCreateResponse, error) {
	rsp, err := c.ConnectTokenCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectTokenCreateResponse(rsp)
}

// ConnectTokenDeleteWithResponse request returning *ConnectTokenDeleteResponse
func (c *ClientWithResponses) ConnectTokenDeleteWithResponse(ctx context.Context, connectTokenID ConnectTokenID, reqEditors ...RequestEditorFn) (*ConnectTokenDeleteResponse, error) {
	rsp, err := c.ConnectTokenDelete(ctx, connectTokenID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectTokenDeleteResponse(rsp)
}

// ConnectTokenUpdateWithBodyWithResponse request with arbitrary body returning *ConnectTokenUpdateResponse
func (c *ClientWithResponses) ConnectTokenUpdateWithBodyWithResponse(ctx context.Context, connectTokenID ConnectTokenID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConnectTokenUpdateResponse, error) {
	rsp, err := c.ConnectTokenUpdateWithBody(ctx, connectTokenID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectTokenUpdateResponse(rsp)
}

func (c *ClientWithResponses) ConnectTokenUpdateWithResponse(ctx context.Context, connectTokenID ConnectTokenID, body ConnectTokenUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ConnectTokenUpdateResponse, error) {
	rsp, err := c.ConnectTokenUpdate(ctx, connectTokenID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConnectTokenUpdateResponse(rsp)
}

// IdentifierListWithResponse request returning *IdentifierListResponse
func (c *ClientWithResponses) IdentifierListWithResponse(ctx context.Context, params *IdentifierListParams, reqEditors ...RequestEditorFn) (*IdentifierListResponse, error) {
	rsp, err := c.IdentifierList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdentifierListResponse(rsp)
}

// LongSessionGetWithResponse request returning *LongSessionGetResponse
func (c *ClientWithResponses) LongSessionGetWithResponse(ctx context.Context, longSessionID LongSessionID, reqEditors ...RequestEditorFn) (*LongSessionGetResponse, error) {
	rsp, err := c.LongSessionGet(ctx, longSessionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLongSessionGetResponse(rsp)
}

// PasskeyAppendFinishWithBodyWithResponse request with arbitrary body returning *PasskeyAppendFinishResponse
func (c *ClientWithResponses) PasskeyAppendFinishWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyAppendFinishResponse, error) {
	rsp, err := c.PasskeyAppendFinishWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyAppendFinishResponse(rsp)
}

func (c *ClientWithResponses) PasskeyAppendFinishWithResponse(ctx context.Context, body PasskeyAppendFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyAppendFinishResponse, error) {
	rsp, err := c.PasskeyAppendFinish(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyAppendFinishResponse(rsp)
}

// PasskeyAppendStartWithBodyWithResponse request with arbitrary body returning *PasskeyAppendStartResponse
func (c *ClientWithResponses) PasskeyAppendStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyAppendStartResponse, error) {
	rsp, err := c.PasskeyAppendStartWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyAppendStartResponse(rsp)
}

func (c *ClientWithResponses) PasskeyAppendStartWithResponse(ctx context.Context, body PasskeyAppendStartJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyAppendStartResponse, error) {
	rsp, err := c.PasskeyAppendStart(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyAppendStartResponse(rsp)
}

// PasskeyLoginFinishWithBodyWithResponse request with arbitrary body returning *PasskeyLoginFinishResponse
func (c *ClientWithResponses) PasskeyLoginFinishWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyLoginFinishResponse, error) {
	rsp, err := c.PasskeyLoginFinishWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyLoginFinishResponse(rsp)
}

func (c *ClientWithResponses) PasskeyLoginFinishWithResponse(ctx context.Context, body PasskeyLoginFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyLoginFinishResponse, error) {
	rsp, err := c.PasskeyLoginFinish(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyLoginFinishResponse(rsp)
}

// PasskeyLoginStartWithBodyWithResponse request with arbitrary body returning *PasskeyLoginStartResponse
func (c *ClientWithResponses) PasskeyLoginStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyLoginStartResponse, error) {
	rsp, err := c.PasskeyLoginStartWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyLoginStartResponse(rsp)
}

func (c *ClientWithResponses) PasskeyLoginStartWithResponse(ctx context.Context, body PasskeyLoginStartJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyLoginStartResponse, error) {
	rsp, err := c.PasskeyLoginStart(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyLoginStartResponse(rsp)
}

// PasskeyMediationFinishWithBodyWithResponse request with arbitrary body returning *PasskeyMediationFinishResponse
func (c *ClientWithResponses) PasskeyMediationFinishWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyMediationFinishResponse, error) {
	rsp, err := c.PasskeyMediationFinishWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyMediationFinishResponse(rsp)
}

func (c *ClientWithResponses) PasskeyMediationFinishWithResponse(ctx context.Context, body PasskeyMediationFinishJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyMediationFinishResponse, error) {
	rsp, err := c.PasskeyMediationFinish(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyMediationFinishResponse(rsp)
}

// PasskeyMediationStartWithBodyWithResponse request with arbitrary body returning *PasskeyMediationStartResponse
func (c *ClientWithResponses) PasskeyMediationStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyMediationStartResponse, error) {
	rsp, err := c.PasskeyMediationStartWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyMediationStartResponse(rsp)
}

func (c *ClientWithResponses) PasskeyMediationStartWithResponse(ctx context.Context, body PasskeyMediationStartJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyMediationStartResponse, error) {
	rsp, err := c.PasskeyMediationStart(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyMediationStartResponse(rsp)
}

// ProjectConfigUpdateCNAMEWithBodyWithResponse request with arbitrary body returning *ProjectConfigUpdateCNAMEResponse
func (c *ClientWithResponses) ProjectConfigUpdateCNAMEWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectConfigUpdateCNAMEResponse, error) {
	rsp, err := c.ProjectConfigUpdateCNAMEWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectConfigUpdateCNAMEResponse(rsp)
}

func (c *ClientWithResponses) ProjectConfigUpdateCNAMEWithResponse(ctx context.Context, body ProjectConfigUpdateCNAMEJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectConfigUpdateCNAMEResponse, error) {
	rsp, err := c.ProjectConfigUpdateCNAME(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectConfigUpdateCNAMEResponse(rsp)
}

// SocialAccountListWithResponse request returning *SocialAccountListResponse
func (c *ClientWithResponses) SocialAccountListWithResponse(ctx context.Context, params *SocialAccountListParams, reqEditors ...RequestEditorFn) (*SocialAccountListResponse, error) {
	rsp, err := c.SocialAccountList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialAccountListResponse(rsp)
}

// UserCreateWithBodyWithResponse request with arbitrary body returning *UserCreateResponse
func (c *ClientWithResponses) UserCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserCreateResponse, error) {
	rsp, err := c.UserCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserCreateResponse(rsp)
}

func (c *ClientWithResponses) UserCreateWithResponse(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserCreateResponse, error) {
	rsp, err := c.UserCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserCreateResponse(rsp)
}

// UserDeleteWithResponse request returning *UserDeleteResponse
func (c *ClientWithResponses) UserDeleteWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*UserDeleteResponse, error) {
	rsp, err := c.UserDelete(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserDeleteResponse(rsp)
}

// UserGetWithResponse request returning *UserGetResponse
func (c *ClientWithResponses) UserGetWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*UserGetResponse, error) {
	rsp, err := c.UserGet(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserGetResponse(rsp)
}

// UserUpdateWithBodyWithResponse request with arbitrary body returning *UserUpdateResponse
func (c *ClientWithResponses) UserUpdateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateResponse, error) {
	rsp, err := c.UserUpdateWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateResponse(rsp)
}

func (c *ClientWithResponses) UserUpdateWithResponse(ctx context.Context, userID UserID, body UserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateResponse, error) {
	rsp, err := c.UserUpdate(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateResponse(rsp)
}

// AuthEventCreateWithBodyWithResponse request with arbitrary body returning *AuthEventCreateResponse
func (c *ClientWithResponses) AuthEventCreateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthEventCreateResponse, error) {
	rsp, err := c.AuthEventCreateWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthEventCreateResponse(rsp)
}

func (c *ClientWithResponses) AuthEventCreateWithResponse(ctx context.Context, userID UserID, body AuthEventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthEventCreateResponse, error) {
	rsp, err := c.AuthEventCreate(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthEventCreateResponse(rsp)
}

// ChallengeCreateWithBodyWithResponse request with arbitrary body returning *ChallengeCreateResponse
func (c *ClientWithResponses) ChallengeCreateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChallengeCreateResponse, error) {
	rsp, err := c.ChallengeCreateWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChallengeCreateResponse(rsp)
}

func (c *ClientWithResponses) ChallengeCreateWithResponse(ctx context.Context, userID UserID, body ChallengeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChallengeCreateResponse, error) {
	rsp, err := c.ChallengeCreate(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChallengeCreateResponse(rsp)
}

// ChallengeUpdateWithBodyWithResponse request with arbitrary body returning *ChallengeUpdateResponse
func (c *ClientWithResponses) ChallengeUpdateWithBodyWithResponse(ctx context.Context, userID UserID, challengeID ChallengeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChallengeUpdateResponse, error) {
	rsp, err := c.ChallengeUpdateWithBody(ctx, userID, challengeID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChallengeUpdateResponse(rsp)
}

func (c *ClientWithResponses) ChallengeUpdateWithResponse(ctx context.Context, userID UserID, challengeID ChallengeID, body ChallengeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChallengeUpdateResponse, error) {
	rsp, err := c.ChallengeUpdate(ctx, userID, challengeID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChallengeUpdateResponse(rsp)
}

// CredentialListWithResponse request returning *CredentialListResponse
func (c *ClientWithResponses) CredentialListWithResponse(ctx context.Context, userID UserID, params *CredentialListParams, reqEditors ...RequestEditorFn) (*CredentialListResponse, error) {
	rsp, err := c.CredentialList(ctx, userID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialListResponse(rsp)
}

// CredentialDeleteWithResponse request returning *CredentialDeleteResponse
func (c *ClientWithResponses) CredentialDeleteWithResponse(ctx context.Context, userID UserID, credentialID CredentialID, reqEditors ...RequestEditorFn) (*CredentialDeleteResponse, error) {
	rsp, err := c.CredentialDelete(ctx, userID, credentialID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialDeleteResponse(rsp)
}

// IdentifierCreateWithBodyWithResponse request with arbitrary body returning *IdentifierCreateResponse
func (c *ClientWithResponses) IdentifierCreateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IdentifierCreateResponse, error) {
	rsp, err := c.IdentifierCreateWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdentifierCreateResponse(rsp)
}

func (c *ClientWithResponses) IdentifierCreateWithResponse(ctx context.Context, userID UserID, body IdentifierCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IdentifierCreateResponse, error) {
	rsp, err := c.IdentifierCreate(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdentifierCreateResponse(rsp)
}

// IdentifierDeleteWithResponse request returning *IdentifierDeleteResponse
func (c *ClientWithResponses) IdentifierDeleteWithResponse(ctx context.Context, userID UserID, identifierID IdentifierID, reqEditors ...RequestEditorFn) (*IdentifierDeleteResponse, error) {
	rsp, err := c.IdentifierDelete(ctx, userID, identifierID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdentifierDeleteResponse(rsp)
}

// IdentifierUpdateWithBodyWithResponse request with arbitrary body returning *IdentifierUpdateResponse
func (c *ClientWithResponses) IdentifierUpdateWithBodyWithResponse(ctx context.Context, userID UserID, identifierID IdentifierID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IdentifierUpdateResponse, error) {
	rsp, err := c.IdentifierUpdateWithBody(ctx, userID, identifierID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdentifierUpdateResponse(rsp)
}

func (c *ClientWithResponses) IdentifierUpdateWithResponse(ctx context.Context, userID UserID, identifierID IdentifierID, body IdentifierUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*IdentifierUpdateResponse, error) {
	rsp, err := c.IdentifierUpdate(ctx, userID, identifierID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIdentifierUpdateResponse(rsp)
}

// LongSessionCreateWithBodyWithResponse request with arbitrary body returning *LongSessionCreateResponse
func (c *ClientWithResponses) LongSessionCreateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LongSessionCreateResponse, error) {
	rsp, err := c.LongSessionCreateWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLongSessionCreateResponse(rsp)
}

func (c *ClientWithResponses) LongSessionCreateWithResponse(ctx context.Context, userID UserID, body LongSessionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*LongSessionCreateResponse, error) {
	rsp, err := c.LongSessionCreate(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLongSessionCreateResponse(rsp)
}

// UserLongSessionGetWithResponse request returning *UserLongSessionGetResponse
func (c *ClientWithResponses) UserLongSessionGetWithResponse(ctx context.Context, userID UserID, longSessionID LongSessionID, reqEditors ...RequestEditorFn) (*UserLongSessionGetResponse, error) {
	rsp, err := c.UserLongSessionGet(ctx, userID, longSessionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserLongSessionGetResponse(rsp)
}

// LongSessionUpdateWithBodyWithResponse request with arbitrary body returning *LongSessionUpdateResponse
func (c *ClientWithResponses) LongSessionUpdateWithBodyWithResponse(ctx context.Context, userID UserID, longSessionID LongSessionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LongSessionUpdateResponse, error) {
	rsp, err := c.LongSessionUpdateWithBody(ctx, userID, longSessionID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLongSessionUpdateResponse(rsp)
}

func (c *ClientWithResponses) LongSessionUpdateWithResponse(ctx context.Context, userID UserID, longSessionID LongSessionID, body LongSessionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LongSessionUpdateResponse, error) {
	rsp, err := c.LongSessionUpdate(ctx, userID, longSessionID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLongSessionUpdateResponse(rsp)
}

// ShortSessionCreateWithBodyWithResponse request with arbitrary body returning *ShortSessionCreateResponse
func (c *ClientWithResponses) ShortSessionCreateWithBodyWithResponse(ctx context.Context, userID UserID, longSessionID LongSessionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShortSessionCreateResponse, error) {
	rsp, err := c.ShortSessionCreateWithBody(ctx, userID, longSessionID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShortSessionCreateResponse(rsp)
}

func (c *ClientWithResponses) ShortSessionCreateWithResponse(ctx context.Context, userID UserID, longSessionID LongSessionID, body ShortSessionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ShortSessionCreateResponse, error) {
	rsp, err := c.ShortSessionCreate(ctx, userID, longSessionID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShortSessionCreateResponse(rsp)
}

// PasskeyChallengeListWithResponse request returning *PasskeyChallengeListResponse
func (c *ClientWithResponses) PasskeyChallengeListWithResponse(ctx context.Context, userID UserID, params *PasskeyChallengeListParams, reqEditors ...RequestEditorFn) (*PasskeyChallengeListResponse, error) {
	rsp, err := c.PasskeyChallengeList(ctx, userID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyChallengeListResponse(rsp)
}

// PasskeyChallengeUpdateWithBodyWithResponse request with arbitrary body returning *PasskeyChallengeUpdateResponse
func (c *ClientWithResponses) PasskeyChallengeUpdateWithBodyWithResponse(ctx context.Context, userID UserID, passkeyChallengeID PasskeyChallengeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyChallengeUpdateResponse, error) {
	rsp, err := c.PasskeyChallengeUpdateWithBody(ctx, userID, passkeyChallengeID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyChallengeUpdateResponse(rsp)
}

func (c *ClientWithResponses) PasskeyChallengeUpdateWithResponse(ctx context.Context, userID UserID, passkeyChallengeID PasskeyChallengeID, body PasskeyChallengeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyChallengeUpdateResponse, error) {
	rsp, err := c.PasskeyChallengeUpdate(ctx, userID, passkeyChallengeID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyChallengeUpdateResponse(rsp)
}

// PasskeyEventListWithResponse request returning *PasskeyEventListResponse
func (c *ClientWithResponses) PasskeyEventListWithResponse(ctx context.Context, userID UserID, params *PasskeyEventListParams, reqEditors ...RequestEditorFn) (*PasskeyEventListResponse, error) {
	rsp, err := c.PasskeyEventList(ctx, userID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyEventListResponse(rsp)
}

// PasskeyEventCreateWithBodyWithResponse request with arbitrary body returning *PasskeyEventCreateResponse
func (c *ClientWithResponses) PasskeyEventCreateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PasskeyEventCreateResponse, error) {
	rsp, err := c.PasskeyEventCreateWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyEventCreateResponse(rsp)
}

func (c *ClientWithResponses) PasskeyEventCreateWithResponse(ctx context.Context, userID UserID, body PasskeyEventCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PasskeyEventCreateResponse, error) {
	rsp, err := c.PasskeyEventCreate(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyEventCreateResponse(rsp)
}

// PasskeyEventDeleteWithResponse request returning *PasskeyEventDeleteResponse
func (c *ClientWithResponses) PasskeyEventDeleteWithResponse(ctx context.Context, userID UserID, passkeyEventID PasskeyEventID, reqEditors ...RequestEditorFn) (*PasskeyEventDeleteResponse, error) {
	rsp, err := c.PasskeyEventDelete(ctx, userID, passkeyEventID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePasskeyEventDeleteResponse(rsp)
}

// UserSocialAccountListWithResponse request returning *UserSocialAccountListResponse
func (c *ClientWithResponses) UserSocialAccountListWithResponse(ctx context.Context, userID UserID, params *UserSocialAccountListParams, reqEditors ...RequestEditorFn) (*UserSocialAccountListResponse, error) {
	rsp, err := c.UserSocialAccountList(ctx, userID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserSocialAccountListResponse(rsp)
}

// SocialAccountCreateWithBodyWithResponse request with arbitrary body returning *SocialAccountCreateResponse
func (c *ClientWithResponses) SocialAccountCreateWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SocialAccountCreateResponse, error) {
	rsp, err := c.SocialAccountCreateWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialAccountCreateResponse(rsp)
}

func (c *ClientWithResponses) SocialAccountCreateWithResponse(ctx context.Context, userID UserID, body SocialAccountCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SocialAccountCreateResponse, error) {
	rsp, err := c.SocialAccountCreate(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSocialAccountCreateResponse(rsp)
}

// ParseConnectTokenListResponse parses an HTTP response from a ConnectTokenListWithResponse call
func ParseConnectTokenListResponse(rsp *http.Response) (*ConnectTokenListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectTokenListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectTokenList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseConnectTokenCreateResponse parses an HTTP response from a ConnectTokenCreateWithResponse call
func ParseConnectTokenCreateResponse(rsp *http.Response) (*ConnectTokenCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectTokenCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseConnectTokenDeleteResponse parses an HTTP response from a ConnectTokenDeleteWithResponse call
func ParseConnectTokenDeleteResponse(rsp *http.Response) (*ConnectTokenDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectTokenDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseConnectTokenUpdateResponse parses an HTTP response from a ConnectTokenUpdateWithResponse call
func ParseConnectTokenUpdateResponse(rsp *http.Response) (*ConnectTokenUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConnectTokenUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseIdentifierListResponse parses an HTTP response from a IdentifierListWithResponse call
func ParseIdentifierListResponse(rsp *http.Response) (*IdentifierListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdentifierListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IdentifierList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLongSessionGetResponse parses an HTTP response from a LongSessionGetWithResponse call
func ParseLongSessionGetResponse(rsp *http.Response) (*LongSessionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LongSessionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LongSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePasskeyAppendFinishResponse parses an HTTP response from a PasskeyAppendFinishWithResponse call
func ParsePasskeyAppendFinishResponse(rsp *http.Response) (*PasskeyAppendFinishResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeyAppendFinishResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasskeyAppendFinishRsp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePasskeyAppendStartResponse parses an HTTP response from a PasskeyAppendStartWithResponse call
func ParsePasskeyAppendStartResponse(rsp *http.Response) (*PasskeyAppendStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeyAppendStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasskeyAppendStartRsp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePasskeyLoginFinishResponse parses an HTTP response from a PasskeyLoginFinishWithResponse call
func ParsePasskeyLoginFinishResponse(rsp *http.Response) (*PasskeyLoginFinishResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeyLoginFinishResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasskeyLoginFinishRsp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePasskeyLoginStartResponse parses an HTTP response from a PasskeyLoginStartWithResponse call
func ParsePasskeyLoginStartResponse(rsp *http.Response) (*PasskeyLoginStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeyLoginStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasskeyLoginStartRsp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePasskeyMediationFinishResponse parses an HTTP response from a PasskeyMediationFinishWithResponse call
func ParsePasskeyMediationFinishResponse(rsp *http.Response) (*PasskeyMediationFinishResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeyMediationFinishResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasskeyMediationFinishRsp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePasskeyMediationStartResponse parses an HTTP response from a PasskeyMediationStartWithResponse call
func ParsePasskeyMediationStartResponse(rsp *http.Response) (*PasskeyMediationStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeyMediationStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasskeyMediationStartRsp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProjectConfigUpdateCNAMEResponse parses an HTTP response from a ProjectConfigUpdateCNAMEWithResponse call
func ParseProjectConfigUpdateCNAMEResponse(rsp *http.Response) (*ProjectConfigUpdateCNAMEResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectConfigUpdateCNAMEResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSocialAccountListResponse parses an HTTP response from a SocialAccountListWithResponse call
func ParseSocialAccountListResponse(rsp *http.Response) (*SocialAccountListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SocialAccountListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SocialAccountList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserCreateResponse parses an HTTP response from a UserCreateWithResponse call
func ParseUserCreateResponse(rsp *http.Response) (*UserCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserDeleteResponse parses an HTTP response from a UserDeleteWithResponse call
func ParseUserDeleteResponse(rsp *http.Response) (*UserDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserGetResponse parses an HTTP response from a UserGetWithResponse call
func ParseUserGetResponse(rsp *http.Response) (*UserGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserUpdateResponse parses an HTTP response from a UserUpdateWithResponse call
func ParseUserUpdateResponse(rsp *http.Response) (*UserUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAuthEventCreateResponse parses an HTTP response from a AuthEventCreateWithResponse call
func ParseAuthEventCreateResponse(rsp *http.Response) (*AuthEventCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthEventCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseChallengeCreateResponse parses an HTTP response from a ChallengeCreateWithResponse call
func ParseChallengeCreateResponse(rsp *http.Response) (*ChallengeCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChallengeCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Challenge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseChallengeUpdateResponse parses an HTTP response from a ChallengeUpdateWithResponse call
func ParseChallengeUpdateResponse(rsp *http.Response) (*ChallengeUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChallengeUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Challenge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCredentialListResponse parses an HTTP response from a CredentialListWithResponse call
func ParseCredentialListResponse(rsp *http.Response) (*CredentialListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CredentialListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCredentialDeleteResponse parses an HTTP response from a CredentialDeleteWithResponse call
func ParseCredentialDeleteResponse(rsp *http.Response) (*CredentialDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CredentialDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseIdentifierCreateResponse parses an HTTP response from a IdentifierCreateWithResponse call
func ParseIdentifierCreateResponse(rsp *http.Response) (*IdentifierCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdentifierCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Identifier
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseIdentifierDeleteResponse parses an HTTP response from a IdentifierDeleteWithResponse call
func ParseIdentifierDeleteResponse(rsp *http.Response) (*IdentifierDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdentifierDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseIdentifierUpdateResponse parses an HTTP response from a IdentifierUpdateWithResponse call
func ParseIdentifierUpdateResponse(rsp *http.Response) (*IdentifierUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IdentifierUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Identifier
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLongSessionCreateResponse parses an HTTP response from a LongSessionCreateWithResponse call
func ParseLongSessionCreateResponse(rsp *http.Response) (*LongSessionCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LongSessionCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LongSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserLongSessionGetResponse parses an HTTP response from a UserLongSessionGetWithResponse call
func ParseUserLongSessionGetResponse(rsp *http.Response) (*UserLongSessionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserLongSessionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LongSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLongSessionUpdateResponse parses an HTTP response from a LongSessionUpdateWithResponse call
func ParseLongSessionUpdateResponse(rsp *http.Response) (*LongSessionUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LongSessionUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LongSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShortSessionCreateResponse parses an HTTP response from a ShortSessionCreateWithResponse call
func ParseShortSessionCreateResponse(rsp *http.Response) (*ShortSessionCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShortSessionCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ShortSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePasskeyChallengeListResponse parses an HTTP response from a PasskeyChallengeListWithResponse call
func ParsePasskeyChallengeListResponse(rsp *http.Response) (*PasskeyChallengeListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeyChallengeListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasskeyChallengeList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePasskeyChallengeUpdateResponse parses an HTTP response from a PasskeyChallengeUpdateWithResponse call
func ParsePasskeyChallengeUpdateResponse(rsp *http.Response) (*PasskeyChallengeUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeyChallengeUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasskeyChallenge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePasskeyEventListResponse parses an HTTP response from a PasskeyEventListWithResponse call
func ParsePasskeyEventListResponse(rsp *http.Response) (*PasskeyEventListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeyEventListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasskeyEventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePasskeyEventCreateResponse parses an HTTP response from a PasskeyEventCreateWithResponse call
func ParsePasskeyEventCreateResponse(rsp *http.Response) (*PasskeyEventCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeyEventCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasskeyEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePasskeyEventDeleteResponse parses an HTTP response from a PasskeyEventDeleteWithResponse call
func ParsePasskeyEventDeleteResponse(rsp *http.Response) (*PasskeyEventDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PasskeyEventDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserSocialAccountListResponse parses an HTTP response from a UserSocialAccountListWithResponse call
func ParseUserSocialAccountListResponse(rsp *http.Response) (*UserSocialAccountListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserSocialAccountListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SocialAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSocialAccountCreateResponse parses an HTTP response from a SocialAccountCreateWithResponse call
func ParseSocialAccountCreateResponse(rsp *http.Response) (*SocialAccountCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SocialAccountCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SocialAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
